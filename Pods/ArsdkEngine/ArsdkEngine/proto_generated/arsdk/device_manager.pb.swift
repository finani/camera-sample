// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: arsdk/device_manager.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Arsdk_Devicemanager_ConnectionFailureReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case peerLimit // = 0
  case authenticationFailed // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .peerLimit
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .peerLimit
    case 1: self = .authenticationFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .peerLimit: return 0
    case .authenticationFailed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Devicemanager_ConnectionFailureReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Devicemanager_ConnectionFailureReason] = [
    .peerLimit,
    .authenticationFailed,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Devicemanager_Transport: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case wifi // = 0
  case cellular // = 1
  case microhard // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .wifi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .wifi
    case 1: self = .cellular
    case 2: self = .microhard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .wifi: return 0
    case .cellular: return 1
    case .microhard: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Devicemanager_Transport: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Devicemanager_Transport] = [
    .wifi,
    .cellular,
    .microhard,
  ]
}

#endif  // swift(>=4.2)

enum Arsdk_Devicemanager_WifiSecurity: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case wpa2 // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .wpa2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .wpa2: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Arsdk_Devicemanager_WifiSecurity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Arsdk_Devicemanager_WifiSecurity] = [
    .none,
    .wpa2,
  ]
}

#endif  // swift(>=4.2)

/// This is the entry point to send messages to the device
struct Arsdk_Devicemanager_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Devicemanager_Command.OneOf_ID? = nil

  var getState: Arsdk_Devicemanager_Command.GetState {
    get {
      if case .getState(let v)? = id {return v}
      return Arsdk_Devicemanager_Command.GetState()
    }
    set {id = .getState(newValue)}
  }

  var connectDevice: Arsdk_Devicemanager_Command.ConnectDevice {
    get {
      if case .connectDevice(let v)? = id {return v}
      return Arsdk_Devicemanager_Command.ConnectDevice()
    }
    set {id = .connectDevice(newValue)}
  }

  var forgetDevice: Arsdk_Devicemanager_Command.ForgetDevice {
    get {
      if case .forgetDevice(let v)? = id {return v}
      return Arsdk_Devicemanager_Command.ForgetDevice()
    }
    set {id = .forgetDevice(newValue)}
  }

  var discoverDevices: Arsdk_Devicemanager_Command.DiscoverDevices {
    get {
      if case .discoverDevices(let v)? = id {return v}
      return Arsdk_Devicemanager_Command.DiscoverDevices()
    }
    set {id = .discoverDevices(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case getState(Arsdk_Devicemanager_Command.GetState)
    case connectDevice(Arsdk_Devicemanager_Command.ConnectDevice)
    case forgetDevice(Arsdk_Devicemanager_Command.ForgetDevice)
    case discoverDevices(Arsdk_Devicemanager_Command.DiscoverDevices)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Devicemanager_Command.OneOf_ID, rhs: Arsdk_Devicemanager_Command.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getState, .getState): return {
        guard case .getState(let l) = lhs, case .getState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectDevice, .connectDevice): return {
        guard case .connectDevice(let l) = lhs, case .connectDevice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forgetDevice, .forgetDevice): return {
        guard case .forgetDevice(let l) = lhs, case .forgetDevice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discoverDevices, .discoverDevices): return {
        guard case .discoverDevices(let l) = lhs, case .discoverDevices(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct GetState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var includeDefaultCapabilities: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ConnectDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uid: String = String()

    var transport: Arsdk_Devicemanager_Command.ConnectDevice.OneOf_Transport? = nil

    var wifi: Arsdk_Devicemanager_Command.ConnectDevice.Wifi {
      get {
        if case .wifi(let v)? = transport {return v}
        return Arsdk_Devicemanager_Command.ConnectDevice.Wifi()
      }
      set {transport = .wifi(newValue)}
    }

    var cellular: Arsdk_Devicemanager_Command.ConnectDevice.Cellular {
      get {
        if case .cellular(let v)? = transport {return v}
        return Arsdk_Devicemanager_Command.ConnectDevice.Cellular()
      }
      set {transport = .cellular(newValue)}
    }

    var microhard: Arsdk_Devicemanager_Command.ConnectDevice.Microhard {
      get {
        if case .microhard(let v)? = transport {return v}
        return Arsdk_Devicemanager_Command.ConnectDevice.Microhard()
      }
      set {transport = .microhard(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Transport: Equatable {
      case wifi(Arsdk_Devicemanager_Command.ConnectDevice.Wifi)
      case cellular(Arsdk_Devicemanager_Command.ConnectDevice.Cellular)
      case microhard(Arsdk_Devicemanager_Command.ConnectDevice.Microhard)

    #if !swift(>=4.1)
      static func ==(lhs: Arsdk_Devicemanager_Command.ConnectDevice.OneOf_Transport, rhs: Arsdk_Devicemanager_Command.ConnectDevice.OneOf_Transport) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.wifi, .wifi): return {
          guard case .wifi(let l) = lhs, case .wifi(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cellular, .cellular): return {
          guard case .cellular(let l) = lhs, case .cellular(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.microhard, .microhard): return {
          guard case .microhard(let l) = lhs, case .microhard(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct Wifi {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var securityKey: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Cellular {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Microhard {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// leave empty to use default
      var power: SwiftProtobuf.Google_Protobuf_UInt32Value {
        get {return _power ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
        set {_power = newValue}
      }
      /// Returns true if `power` has been explicitly set.
      var hasPower: Bool {return self._power != nil}
      /// Clears the value of `power`. Subsequent reads from it will return its default value.
      mutating func clearPower() {self._power = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _power: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    }

    init() {}
  }

  struct ForgetDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DiscoverDevices {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// This is the entry point to receive messages from the device
struct Arsdk_Devicemanager_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Arsdk_Devicemanager_Event.OneOf_ID? = nil

  var state: Arsdk_Devicemanager_Event.State {
    get {
      if case .state(let v)? = id {return v}
      return Arsdk_Devicemanager_Event.State()
    }
    set {id = .state(newValue)}
  }

  var connectionFailure: Arsdk_Devicemanager_Event.ConnectionFailure {
    get {
      if case .connectionFailure(let v)? = id {return v}
      return Arsdk_Devicemanager_Event.ConnectionFailure()
    }
    set {id = .connectionFailure(newValue)}
  }

  var discoveredDevices: Arsdk_Devicemanager_Event.DiscoveredDevices {
    get {
      if case .discoveredDevices(let v)? = id {return v}
      return Arsdk_Devicemanager_Event.DiscoveredDevices()
    }
    set {id = .discoveredDevices(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case state(Arsdk_Devicemanager_Event.State)
    case connectionFailure(Arsdk_Devicemanager_Event.ConnectionFailure)
    case discoveredDevices(Arsdk_Devicemanager_Event.DiscoveredDevices)

  #if !swift(>=4.1)
    static func ==(lhs: Arsdk_Devicemanager_Event.OneOf_ID, rhs: Arsdk_Devicemanager_Event.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionFailure, .connectionFailure): return {
        guard case .connectionFailure(let l) = lhs, case .connectionFailure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discoveredDevices, .discoveredDevices): return {
        guard case .discoveredDevices(let l) = lhs, case .discoveredDevices(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct State {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var defaultCapabilities: Arsdk_Devicemanager_Capabilities {
      get {return _defaultCapabilities ?? Arsdk_Devicemanager_Capabilities()}
      set {_defaultCapabilities = newValue}
    }
    /// Returns true if `defaultCapabilities` has been explicitly set.
    var hasDefaultCapabilities: Bool {return self._defaultCapabilities != nil}
    /// Clears the value of `defaultCapabilities`. Subsequent reads from it will return its default value.
    mutating func clearDefaultCapabilities() {self._defaultCapabilities = nil}

    var knownDevices: Arsdk_Devicemanager_Event.State.KnownDevices {
      get {return _knownDevices ?? Arsdk_Devicemanager_Event.State.KnownDevices()}
      set {_knownDevices = newValue}
    }
    /// Returns true if `knownDevices` has been explicitly set.
    var hasKnownDevices: Bool {return self._knownDevices != nil}
    /// Clears the value of `knownDevices`. Subsequent reads from it will return its default value.
    mutating func clearKnownDevices() {self._knownDevices = nil}

    var connectionState: Arsdk_Devicemanager_Event.State.OneOf_ConnectionState? = nil

    var idle: Arsdk_Devicemanager_ConnectionState.Idle {
      get {
        if case .idle(let v)? = connectionState {return v}
        return Arsdk_Devicemanager_ConnectionState.Idle()
      }
      set {connectionState = .idle(newValue)}
    }

    var searching: Arsdk_Devicemanager_ConnectionState.Searching {
      get {
        if case .searching(let v)? = connectionState {return v}
        return Arsdk_Devicemanager_ConnectionState.Searching()
      }
      set {connectionState = .searching(newValue)}
    }

    var connecting: Arsdk_Devicemanager_ConnectionState.Connecting {
      get {
        if case .connecting(let v)? = connectionState {return v}
        return Arsdk_Devicemanager_ConnectionState.Connecting()
      }
      set {connectionState = .connecting(newValue)}
    }

    var connected: Arsdk_Devicemanager_ConnectionState.Connected {
      get {
        if case .connected(let v)? = connectionState {return v}
        return Arsdk_Devicemanager_ConnectionState.Connected()
      }
      set {connectionState = .connected(newValue)}
    }

    var disconnecting: Arsdk_Devicemanager_ConnectionState.Disconnecting {
      get {
        if case .disconnecting(let v)? = connectionState {return v}
        return Arsdk_Devicemanager_ConnectionState.Disconnecting()
      }
      set {connectionState = .disconnecting(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ConnectionState: Equatable {
      case idle(Arsdk_Devicemanager_ConnectionState.Idle)
      case searching(Arsdk_Devicemanager_ConnectionState.Searching)
      case connecting(Arsdk_Devicemanager_ConnectionState.Connecting)
      case connected(Arsdk_Devicemanager_ConnectionState.Connected)
      case disconnecting(Arsdk_Devicemanager_ConnectionState.Disconnecting)

    #if !swift(>=4.1)
      static func ==(lhs: Arsdk_Devicemanager_Event.State.OneOf_ConnectionState, rhs: Arsdk_Devicemanager_Event.State.OneOf_ConnectionState) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.idle, .idle): return {
          guard case .idle(let l) = lhs, case .idle(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.searching, .searching): return {
          guard case .searching(let l) = lhs, case .searching(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.connecting, .connecting): return {
          guard case .connecting(let l) = lhs, case .connecting(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.connected, .connected): return {
          guard case .connected(let l) = lhs, case .connected(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.disconnecting, .disconnecting): return {
          guard case .disconnecting(let l) = lhs, case .disconnecting(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct KnownDevices {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var devices: [Arsdk_Devicemanager_KnownDevice] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _defaultCapabilities: Arsdk_Devicemanager_Capabilities? = nil
    fileprivate var _knownDevices: Arsdk_Devicemanager_Event.State.KnownDevices? = nil
  }

  struct ConnectionFailure {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Arsdk_Devicemanager_DeviceInfo {
      get {return _device ?? Arsdk_Devicemanager_DeviceInfo()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() {self._device = nil}

    var transport: Arsdk_Devicemanager_Transport = .wifi

    var reason: Arsdk_Devicemanager_ConnectionFailureReason = .peerLimit

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _device: Arsdk_Devicemanager_DeviceInfo? = nil
  }

  struct DiscoveredDevices {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var devices: [Arsdk_Devicemanager_DiscoveredDevice] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Arsdk_Devicemanager_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var discoveryTransports: [Arsdk_Devicemanager_Transport] = []

  /// null if no microhard support
  var microhard: Arsdk_Devicemanager_Capabilities.Microhard {
    get {return _microhard ?? Arsdk_Devicemanager_Capabilities.Microhard()}
    set {_microhard = newValue}
  }
  /// Returns true if `microhard` has been explicitly set.
  var hasMicrohard: Bool {return self._microhard != nil}
  /// Clears the value of `microhard`. Subsequent reads from it will return its default value.
  mutating func clearMicrohard() {self._microhard = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Microhard {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var powerMin: UInt32 = 0

    var powerMax: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _microhard: Arsdk_Devicemanager_Capabilities.Microhard? = nil
}

struct Arsdk_Devicemanager_ConnectionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Idle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Searching {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Connecting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Arsdk_Devicemanager_DeviceInfo {
      get {return _device ?? Arsdk_Devicemanager_DeviceInfo()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() {self._device = nil}

    var transport: Arsdk_Devicemanager_Transport = .wifi

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _device: Arsdk_Devicemanager_DeviceInfo? = nil
  }

  struct Connected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Arsdk_Devicemanager_DeviceInfo {
      get {return _device ?? Arsdk_Devicemanager_DeviceInfo()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() {self._device = nil}

    var transport: Arsdk_Devicemanager_Transport = .wifi

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _device: Arsdk_Devicemanager_DeviceInfo? = nil
  }

  struct Disconnecting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Arsdk_Devicemanager_DeviceInfo {
      get {return _device ?? Arsdk_Devicemanager_DeviceInfo()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() {self._device = nil}

    var transport: Arsdk_Devicemanager_Transport = .wifi

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _device: Arsdk_Devicemanager_DeviceInfo? = nil
  }

  init() {}
}

struct Arsdk_Devicemanager_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uid: String = String()

  var model: UInt32 = 0

  var networkID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Devicemanager_WifiInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var security: Arsdk_Devicemanager_WifiSecurity = .none

  var savedKey: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Devicemanager_CellularInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Devicemanager_MicrohardInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var power: UInt32 = 0

  var channel: UInt32 = 0

  var bandwidth: Arsdk_Microhard_Bandwidth = .bandwidth1Mhz

  var encryptionAlgorithm: Arsdk_Microhard_Encryption = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Arsdk_Devicemanager_KnownDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Arsdk_Devicemanager_DeviceInfo {
    get {return _info ?? Arsdk_Devicemanager_DeviceInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var wifi: Arsdk_Devicemanager_WifiInfo {
    get {return _wifi ?? Arsdk_Devicemanager_WifiInfo()}
    set {_wifi = newValue}
  }
  /// Returns true if `wifi` has been explicitly set.
  var hasWifi: Bool {return self._wifi != nil}
  /// Clears the value of `wifi`. Subsequent reads from it will return its default value.
  mutating func clearWifi() {self._wifi = nil}

  var cellular: Arsdk_Devicemanager_CellularInfo {
    get {return _cellular ?? Arsdk_Devicemanager_CellularInfo()}
    set {_cellular = newValue}
  }
  /// Returns true if `cellular` has been explicitly set.
  var hasCellular: Bool {return self._cellular != nil}
  /// Clears the value of `cellular`. Subsequent reads from it will return its default value.
  mutating func clearCellular() {self._cellular = nil}

  var microhard: Arsdk_Devicemanager_MicrohardInfo {
    get {return _microhard ?? Arsdk_Devicemanager_MicrohardInfo()}
    set {_microhard = newValue}
  }
  /// Returns true if `microhard` has been explicitly set.
  var hasMicrohard: Bool {return self._microhard != nil}
  /// Clears the value of `microhard`. Subsequent reads from it will return its default value.
  mutating func clearMicrohard() {self._microhard = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Arsdk_Devicemanager_DeviceInfo? = nil
  fileprivate var _wifi: Arsdk_Devicemanager_WifiInfo? = nil
  fileprivate var _cellular: Arsdk_Devicemanager_CellularInfo? = nil
  fileprivate var _microhard: Arsdk_Devicemanager_MicrohardInfo? = nil
}

struct Arsdk_Devicemanager_DiscoveredDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Arsdk_Devicemanager_DeviceInfo {
    get {return _info ?? Arsdk_Devicemanager_DeviceInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var known: Bool = false

  var wifiVisibility: Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility {
    get {return _wifiVisibility ?? Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility()}
    set {_wifiVisibility = newValue}
  }
  /// Returns true if `wifiVisibility` has been explicitly set.
  var hasWifiVisibility: Bool {return self._wifiVisibility != nil}
  /// Clears the value of `wifiVisibility`. Subsequent reads from it will return its default value.
  mutating func clearWifiVisibility() {self._wifiVisibility = nil}

  var cellularVisibility: Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility {
    get {return _cellularVisibility ?? Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility()}
    set {_cellularVisibility = newValue}
  }
  /// Returns true if `cellularVisibility` has been explicitly set.
  var hasCellularVisibility: Bool {return self._cellularVisibility != nil}
  /// Clears the value of `cellularVisibility`. Subsequent reads from it will return its default value.
  mutating func clearCellularVisibility() {self._cellularVisibility = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WifiVisibility {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transportInfo: Arsdk_Devicemanager_WifiInfo {
      get {return _transportInfo ?? Arsdk_Devicemanager_WifiInfo()}
      set {_transportInfo = newValue}
    }
    /// Returns true if `transportInfo` has been explicitly set.
    var hasTransportInfo: Bool {return self._transportInfo != nil}
    /// Clears the value of `transportInfo`. Subsequent reads from it will return its default value.
    mutating func clearTransportInfo() {self._transportInfo = nil}

    var rssi: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transportInfo: Arsdk_Devicemanager_WifiInfo? = nil
  }

  struct CellularVisibility {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transportInfo: Arsdk_Devicemanager_CellularInfo {
      get {return _transportInfo ?? Arsdk_Devicemanager_CellularInfo()}
      set {_transportInfo = newValue}
    }
    /// Returns true if `transportInfo` has been explicitly set.
    var hasTransportInfo: Bool {return self._transportInfo != nil}
    /// Clears the value of `transportInfo`. Subsequent reads from it will return its default value.
    mutating func clearTransportInfo() {self._transportInfo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transportInfo: Arsdk_Devicemanager_CellularInfo? = nil
  }

  init() {}

  fileprivate var _info: Arsdk_Devicemanager_DeviceInfo? = nil
  fileprivate var _wifiVisibility: Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility? = nil
  fileprivate var _cellularVisibility: Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arsdk.devicemanager"

extension Arsdk_Devicemanager_ConnectionFailureReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_FAILURE_REASON_PEER_LIMIT"),
    1: .same(proto: "CONNECTION_FAILURE_REASON_AUTHENTICATION_FAILED"),
  ]
}

extension Arsdk_Devicemanager_Transport: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSPORT_WIFI"),
    1: .same(proto: "TRANSPORT_CELLULAR"),
    2: .same(proto: "TRANSPORT_MICROHARD"),
  ]
}

extension Arsdk_Devicemanager_WifiSecurity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WIFI_SECURITY_NONE"),
    1: .same(proto: "WIFI_SECURITY_WPA2"),
  ]
}

extension Arsdk_Devicemanager_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "get_state"),
    17: .standard(proto: "connect_device"),
    18: .standard(proto: "forget_device"),
    19: .standard(proto: "discover_devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try {
        var v: Arsdk_Devicemanager_Command.GetState?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .getState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .getState(v)
        }
      }()
      case 17: try {
        var v: Arsdk_Devicemanager_Command.ConnectDevice?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .connectDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .connectDevice(v)
        }
      }()
      case 18: try {
        var v: Arsdk_Devicemanager_Command.ForgetDevice?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .forgetDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .forgetDevice(v)
        }
      }()
      case 19: try {
        var v: Arsdk_Devicemanager_Command.DiscoverDevices?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .discoverDevices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .discoverDevices(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .getState?: try {
      guard case .getState(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .connectDevice?: try {
      guard case .connectDevice(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .forgetDevice?: try {
      guard case .forgetDevice(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .discoverDevices?: try {
      guard case .discoverDevices(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command, rhs: Arsdk_Devicemanager_Command) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.GetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.protoMessageName + ".GetState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_default_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeDefaultCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeDefaultCapabilities != false {
      try visitor.visitSingularBoolField(value: self.includeDefaultCapabilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.GetState, rhs: Arsdk_Devicemanager_Command.GetState) -> Bool {
    if lhs.includeDefaultCapabilities != rhs.includeDefaultCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.ConnectDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.protoMessageName + ".ConnectDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "wifi"),
    3: .same(proto: "cellular"),
    4: .same(proto: "microhard"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try {
        var v: Arsdk_Devicemanager_Command.ConnectDevice.Wifi?
        var hadOneofValue = false
        if let current = self.transport {
          hadOneofValue = true
          if case .wifi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transport = .wifi(v)
        }
      }()
      case 3: try {
        var v: Arsdk_Devicemanager_Command.ConnectDevice.Cellular?
        var hadOneofValue = false
        if let current = self.transport {
          hadOneofValue = true
          if case .cellular(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transport = .cellular(v)
        }
      }()
      case 4: try {
        var v: Arsdk_Devicemanager_Command.ConnectDevice.Microhard?
        var hadOneofValue = false
        if let current = self.transport {
          hadOneofValue = true
          if case .microhard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transport = .microhard(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    switch self.transport {
    case .wifi?: try {
      guard case .wifi(let v)? = self.transport else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cellular?: try {
      guard case .cellular(let v)? = self.transport else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .microhard?: try {
      guard case .microhard(let v)? = self.transport else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.ConnectDevice, rhs: Arsdk_Devicemanager_Command.ConnectDevice) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.transport != rhs.transport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.ConnectDevice.Wifi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.ConnectDevice.protoMessageName + ".Wifi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "security_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.securityKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.securityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.securityKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.ConnectDevice.Wifi, rhs: Arsdk_Devicemanager_Command.ConnectDevice.Wifi) -> Bool {
    if lhs.securityKey != rhs.securityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.ConnectDevice.Cellular: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.ConnectDevice.protoMessageName + ".Cellular"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.ConnectDevice.Cellular, rhs: Arsdk_Devicemanager_Command.ConnectDevice.Cellular) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.ConnectDevice.Microhard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.ConnectDevice.protoMessageName + ".Microhard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._power {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.ConnectDevice.Microhard, rhs: Arsdk_Devicemanager_Command.ConnectDevice.Microhard) -> Bool {
    if lhs._power != rhs._power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.ForgetDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.protoMessageName + ".ForgetDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.ForgetDevice, rhs: Arsdk_Devicemanager_Command.ForgetDevice) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Command.DiscoverDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Command.protoMessageName + ".DiscoverDevices"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Command.DiscoverDevices, rhs: Arsdk_Devicemanager_Command.DiscoverDevices) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .same(proto: "state"),
    17: .standard(proto: "connection_failure"),
    18: .standard(proto: "discovered_devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try {
        var v: Arsdk_Devicemanager_Event.State?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .state(v)
        }
      }()
      case 17: try {
        var v: Arsdk_Devicemanager_Event.ConnectionFailure?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .connectionFailure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .connectionFailure(v)
        }
      }()
      case 18: try {
        var v: Arsdk_Devicemanager_Event.DiscoveredDevices?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .discoveredDevices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .discoveredDevices(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .state?: try {
      guard case .state(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .connectionFailure?: try {
      guard case .connectionFailure(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .discoveredDevices?: try {
      guard case .discoveredDevices(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Event, rhs: Arsdk_Devicemanager_Event) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Event.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Event.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_capabilities"),
    3: .standard(proto: "known_devices"),
    4: .same(proto: "idle"),
    5: .same(proto: "searching"),
    6: .same(proto: "connecting"),
    7: .same(proto: "connected"),
    8: .same(proto: "disconnecting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultCapabilities) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._knownDevices) }()
      case 4: try {
        var v: Arsdk_Devicemanager_ConnectionState.Idle?
        var hadOneofValue = false
        if let current = self.connectionState {
          hadOneofValue = true
          if case .idle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectionState = .idle(v)
        }
      }()
      case 5: try {
        var v: Arsdk_Devicemanager_ConnectionState.Searching?
        var hadOneofValue = false
        if let current = self.connectionState {
          hadOneofValue = true
          if case .searching(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectionState = .searching(v)
        }
      }()
      case 6: try {
        var v: Arsdk_Devicemanager_ConnectionState.Connecting?
        var hadOneofValue = false
        if let current = self.connectionState {
          hadOneofValue = true
          if case .connecting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectionState = .connecting(v)
        }
      }()
      case 7: try {
        var v: Arsdk_Devicemanager_ConnectionState.Connected?
        var hadOneofValue = false
        if let current = self.connectionState {
          hadOneofValue = true
          if case .connected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectionState = .connected(v)
        }
      }()
      case 8: try {
        var v: Arsdk_Devicemanager_ConnectionState.Disconnecting?
        var hadOneofValue = false
        if let current = self.connectionState {
          hadOneofValue = true
          if case .disconnecting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectionState = .disconnecting(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._defaultCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._knownDevices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.connectionState {
    case .idle?: try {
      guard case .idle(let v)? = self.connectionState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .searching?: try {
      guard case .searching(let v)? = self.connectionState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .connecting?: try {
      guard case .connecting(let v)? = self.connectionState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .connected?: try {
      guard case .connected(let v)? = self.connectionState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .disconnecting?: try {
      guard case .disconnecting(let v)? = self.connectionState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Event.State, rhs: Arsdk_Devicemanager_Event.State) -> Bool {
    if lhs._defaultCapabilities != rhs._defaultCapabilities {return false}
    if lhs._knownDevices != rhs._knownDevices {return false}
    if lhs.connectionState != rhs.connectionState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Event.State.KnownDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Event.State.protoMessageName + ".KnownDevices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Event.State.KnownDevices, rhs: Arsdk_Devicemanager_Event.State.KnownDevices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Event.ConnectionFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Event.protoMessageName + ".ConnectionFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "transport"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transport) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.transport != .wifi {
      try visitor.visitSingularEnumField(value: self.transport, fieldNumber: 2)
    }
    if self.reason != .peerLimit {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Event.ConnectionFailure, rhs: Arsdk_Devicemanager_Event.ConnectionFailure) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.transport != rhs.transport {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Event.DiscoveredDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Event.protoMessageName + ".DiscoveredDevices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Event.DiscoveredDevices, rhs: Arsdk_Devicemanager_Event.DiscoveredDevices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "discovery_transports"),
    2: .same(proto: "microhard"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.discoveryTransports) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._microhard) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.discoveryTransports.isEmpty {
      try visitor.visitPackedEnumField(value: self.discoveryTransports, fieldNumber: 1)
    }
    try { if let v = self._microhard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Capabilities, rhs: Arsdk_Devicemanager_Capabilities) -> Bool {
    if lhs.discoveryTransports != rhs.discoveryTransports {return false}
    if lhs._microhard != rhs._microhard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_Capabilities.Microhard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_Capabilities.protoMessageName + ".Microhard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "power_min"),
    3: .standard(proto: "power_max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.powerMin) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.powerMax) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerMin, fieldNumber: 2)
    }
    if self.powerMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerMax, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_Capabilities.Microhard, rhs: Arsdk_Devicemanager_Capabilities.Microhard) -> Bool {
    if lhs.powerMin != rhs.powerMin {return false}
    if lhs.powerMax != rhs.powerMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState, rhs: Arsdk_Devicemanager_ConnectionState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState.Idle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_ConnectionState.protoMessageName + ".Idle"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState.Idle, rhs: Arsdk_Devicemanager_ConnectionState.Idle) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState.Searching: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_ConnectionState.protoMessageName + ".Searching"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState.Searching, rhs: Arsdk_Devicemanager_ConnectionState.Searching) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState.Connecting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_ConnectionState.protoMessageName + ".Connecting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "transport"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.transport != .wifi {
      try visitor.visitSingularEnumField(value: self.transport, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState.Connecting, rhs: Arsdk_Devicemanager_ConnectionState.Connecting) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.transport != rhs.transport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState.Connected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_ConnectionState.protoMessageName + ".Connected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "transport"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.transport != .wifi {
      try visitor.visitSingularEnumField(value: self.transport, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState.Connected, rhs: Arsdk_Devicemanager_ConnectionState.Connected) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.transport != rhs.transport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_ConnectionState.Disconnecting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_ConnectionState.protoMessageName + ".Disconnecting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "transport"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.transport != .wifi {
      try visitor.visitSingularEnumField(value: self.transport, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_ConnectionState.Disconnecting, rhs: Arsdk_Devicemanager_ConnectionState.Disconnecting) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.transport != rhs.transport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "model"),
    3: .standard(proto: "network_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.model) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.model != 0 {
      try visitor.visitSingularUInt32Field(value: self.model, fieldNumber: 2)
    }
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_DeviceInfo, rhs: Arsdk_Devicemanager_DeviceInfo) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.model != rhs.model {return false}
    if lhs.networkID != rhs.networkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_WifiInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "security"),
    2: .standard(proto: "saved_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.security) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.savedKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.security != .none {
      try visitor.visitSingularEnumField(value: self.security, fieldNumber: 1)
    }
    if self.savedKey != false {
      try visitor.visitSingularBoolField(value: self.savedKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_WifiInfo, rhs: Arsdk_Devicemanager_WifiInfo) -> Bool {
    if lhs.security != rhs.security {return false}
    if lhs.savedKey != rhs.savedKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_CellularInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellularInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_CellularInfo, rhs: Arsdk_Devicemanager_CellularInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_MicrohardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MicrohardInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "power"),
    2: .same(proto: "channel"),
    3: .same(proto: "bandwidth"),
    4: .standard(proto: "encryption_algorithm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.power) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.bandwidth) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.encryptionAlgorithm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.power != 0 {
      try visitor.visitSingularUInt32Field(value: self.power, fieldNumber: 1)
    }
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 2)
    }
    if self.bandwidth != .bandwidth1Mhz {
      try visitor.visitSingularEnumField(value: self.bandwidth, fieldNumber: 3)
    }
    if self.encryptionAlgorithm != .none {
      try visitor.visitSingularEnumField(value: self.encryptionAlgorithm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_MicrohardInfo, rhs: Arsdk_Devicemanager_MicrohardInfo) -> Bool {
    if lhs.power != rhs.power {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.bandwidth != rhs.bandwidth {return false}
    if lhs.encryptionAlgorithm != rhs.encryptionAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_KnownDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KnownDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "wifi"),
    3: .same(proto: "cellular"),
    4: .same(proto: "microhard"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._wifi) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellular) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._microhard) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wifi {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellular {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._microhard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_KnownDevice, rhs: Arsdk_Devicemanager_KnownDevice) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._wifi != rhs._wifi {return false}
    if lhs._cellular != rhs._cellular {return false}
    if lhs._microhard != rhs._microhard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_DiscoveredDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscoveredDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "known"),
    3: .standard(proto: "wifi_visibility"),
    4: .standard(proto: "cellular_visibility"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.known) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._wifiVisibility) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cellularVisibility) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.known != false {
      try visitor.visitSingularBoolField(value: self.known, fieldNumber: 2)
    }
    try { if let v = self._wifiVisibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cellularVisibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_DiscoveredDevice, rhs: Arsdk_Devicemanager_DiscoveredDevice) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.known != rhs.known {return false}
    if lhs._wifiVisibility != rhs._wifiVisibility {return false}
    if lhs._cellularVisibility != rhs._cellularVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_DiscoveredDevice.protoMessageName + ".WifiVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_info"),
    2: .same(proto: "rssi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transportInfo) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transportInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility, rhs: Arsdk_Devicemanager_DiscoveredDevice.WifiVisibility) -> Bool {
    if lhs._transportInfo != rhs._transportInfo {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Arsdk_Devicemanager_DiscoveredDevice.protoMessageName + ".CellularVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transportInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transportInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility, rhs: Arsdk_Devicemanager_DiscoveredDevice.CellularVisibility) -> Bool {
    if lhs._transportInfo != rhs._transportInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
